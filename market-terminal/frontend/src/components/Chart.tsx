/**
 * Candlestick + volume chart using TradingView Lightweight Charts.
 * Displays OHLCV data for the active ticker with timeframe selection.
 * @generated by code-generator (Agent #19)
 */
import { useEffect, useRef, useState } from 'react';
import {
  createChart,
  ColorType,
  CrosshairMode,
  type IChartApi,
  type ISeriesApi,
  type CandlestickData,
  type HistogramData,
  type Time,
} from 'lightweight-charts';
import { useTickerChart } from '../hooks/useTickerChart';
import {
  TIMEFRAMES,
  TIMEFRAME_LABELS,
  DEFAULT_TIMEFRAME,
  type Timeframe,
  type OHLCVBar,
} from '../types/ticker';
import { useWebSocketContext } from '../contexts/WebSocketContext';
import { WS_CHANNELS } from '../types/websocket';

interface ChartProps {
  readonly symbol: string;
}

/** Dark-theme colour palette for the chart. */
const COLORS = {
  background: '#0a0e17',
  up: '#22c55e',
  down: '#ef4444',
  grid: '#1f2937',
  text: '#8b8b9e',
  border: '#1f2937',
  crosshair: '#4b5563',
  volumeUp: 'rgba(34, 197, 94, 0.3)',
  volumeDown: 'rgba(239, 68, 68, 0.3)',
} as const;

interface ChartSeriesData {
  readonly candles: CandlestickData[];
  readonly volumes: HistogramData[];
}

/**
 * Convert OHLCV bars into candlestick and volume histogram arrays in a single
 * pass (avoids iterating the bar array twice).
 */
function mapBarsSinglePass(bars: readonly OHLCVBar[]): ChartSeriesData {
  const candles: CandlestickData[] = [];
  const volumes: HistogramData[] = [];

  for (const bar of bars) {
    const time = bar.date as Time;

    candles.push({
      time,
      open: bar.open,
      high: bar.high,
      low: bar.low,
      close: bar.close,
    });

    volumes.push({
      time,
      value: bar.volume,
      color: bar.close >= bar.open ? COLORS.volumeUp : COLORS.volumeDown,
    });
  }

  return { candles, volumes };
}

/** Price chart panel with candlestick and volume series. */
export default function Chart({ symbol }: ChartProps) {
  const [timeframe, setTimeframe] = useState<Timeframe>(DEFAULT_TIMEFRAME);
  const { bars, loading, error } = useTickerChart(symbol, timeframe);

  const containerRef = useRef<HTMLDivElement>(null);
  const chartRef = useRef<IChartApi | null>(null);
  const candleSeriesRef = useRef<ISeriesApi<'Candlestick'> | null>(null);
  const volumeSeriesRef = useRef<ISeriesApi<'Histogram'> | null>(null);

  /** Track the last bar so WebSocket price updates can update it in real-time. */
  const lastBarRef = useRef<{
    time: Time;
    open: number;
    high: number;
    low: number;
    close: number;
  } | null>(null);

  const { subscribe, unsubscribe, onMessage } = useWebSocketContext();

  // Mount-only effect: create chart, attach ResizeObserver, cleanup on unmount.
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    let chart: IChartApi;
    try {
      chart = createChart(container, {
        width: container.clientWidth,
        height: container.clientHeight,
        layout: {
          background: { type: ColorType.Solid, color: COLORS.background },
          textColor: COLORS.text,
        },
        grid: {
          vertLines: { color: COLORS.grid },
          horzLines: { color: COLORS.grid },
        },
        crosshair: { mode: CrosshairMode.Normal },
        rightPriceScale: { borderColor: COLORS.border },
        timeScale: {
          borderColor: COLORS.border,
          timeVisible: false,
          secondsVisible: false,
        },
      });
    } catch {
      // Lightweight-charts requires canvas support; skip in test environments.
      return;
    }

    chartRef.current = chart;

    const candleSeries = chart.addCandlestickSeries({
      upColor: COLORS.up,
      downColor: COLORS.down,
      borderUpColor: COLORS.up,
      borderDownColor: COLORS.down,
      wickUpColor: COLORS.up,
      wickDownColor: COLORS.down,
    });
    candleSeriesRef.current = candleSeries;

    const volumeSeries = chart.addHistogramSeries({
      priceFormat: { type: 'volume' },
      priceScaleId: 'volume',
    });
    chart.priceScale('volume').applyOptions({
      scaleMargins: { top: 0.8, bottom: 0 },
    });
    volumeSeriesRef.current = volumeSeries;

    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        chart.applyOptions({ width, height });
      }
    });
    resizeObserver.observe(container);

    return () => {
      resizeObserver.disconnect();
      chart.remove();
      chartRef.current = null;
      candleSeriesRef.current = null;
      volumeSeriesRef.current = null;
    };
  }, []); // mount-only

  // Data update effect: push new bars into existing series.
  useEffect(() => {
    if (!candleSeriesRef.current || !volumeSeriesRef.current) return;
    if (bars.length === 0) {
      candleSeriesRef.current.setData([]);
      volumeSeriesRef.current.setData([]);
      lastBarRef.current = null;
      return;
    }

    const { candles, volumes } = mapBarsSinglePass(bars);
    candleSeriesRef.current.setData(candles);
    volumeSeriesRef.current.setData(volumes);

    // Capture last bar for WebSocket live updates.
    const lastCandle = candles[candles.length - 1];
    if (lastCandle) {
      lastBarRef.current = {
        time: lastCandle.time,
        open: lastCandle.open,
        high: lastCandle.high,
        low: lastCandle.low,
        close: lastCandle.close,
      };
    }

    if (chartRef.current) {
      chartRef.current.timeScale().fitContent();
    }
  }, [bars]);

  // WebSocket live price update effect: update the last candlestick in real-time.
  useEffect(() => {
    if (!symbol) return;

    subscribe(WS_CHANNELS.PriceUpdates);

    const removeListener = onMessage('price_update', (msg) => {
      if (msg.symbol !== symbol) return;
      if (!lastBarRef.current || !candleSeriesRef.current) return;

      const bar = lastBarRef.current;
      bar.close = msg.price;
      bar.high = Math.max(bar.high, msg.price);
      bar.low = Math.min(bar.low, msg.price);

      candleSeriesRef.current.update({
        time: bar.time,
        open: bar.open,
        high: bar.high,
        low: bar.low,
        close: bar.close,
      });
    });

    return () => {
      removeListener();
      unsubscribe(WS_CHANNELS.PriceUpdates);
    };
  }, [symbol, subscribe, unsubscribe, onMessage]);

  return (
    <div className="bg-terminal-panel border border-terminal-border rounded p-4 h-full flex flex-col">
      {/* Header row */}
      <div className="flex items-center justify-between mb-2">
        <h3 className="text-text-primary font-mono text-sm">
          Chart &mdash; {symbol || 'No ticker selected'}
        </h3>

        {/* Timeframe selector */}
        {symbol && (
          <div className="flex gap-1">
            {TIMEFRAMES.map((tf) => (
              <button
                key={tf}
                type="button"
                onClick={() => setTimeframe(tf)}
                className={`
                  px-2 py-0.5 text-xs font-mono rounded transition-colors duration-150
                  ${
                    tf === timeframe
                      ? 'bg-amber-500 text-terminal-bg'
                      : 'text-text-secondary hover:text-text-primary hover:bg-terminal-border'
                  }
                `}
              >
                {TIMEFRAME_LABELS[tf]}
              </button>
            ))}
          </div>
        )}
      </div>

      {/* Chart body */}
      <div className="flex-1 min-h-0 relative">
        {/* Loading skeleton */}
        {loading && (
          <div className="absolute inset-0 flex items-center justify-center z-10">
            <div className="text-text-secondary font-mono text-xs animate-pulse">
              Loading chart data...
            </div>
          </div>
        )}

        {/* Error state */}
        {error && !loading && (
          <div className="absolute inset-0 flex items-center justify-center z-10">
            <p className="text-red-400 font-mono text-xs">{error}</p>
          </div>
        )}

        {/* Empty state (no symbol) */}
        {!symbol && !loading && !error && (
          <div className="absolute inset-0 flex items-center justify-center">
            <p className="text-text-secondary font-mono text-xs">
              Enter a ticker symbol to view chart
            </p>
          </div>
        )}

        {/* Empty data state (symbol set but no bars returned) */}
        {symbol && !loading && !error && bars.length === 0 && (
          <div className="absolute inset-0 flex items-center justify-center">
            <p className="text-text-secondary font-mono text-xs">
              No chart data available
            </p>
          </div>
        )}

        {/* Chart container */}
        <div
          ref={containerRef}
          className="w-full h-full"
          data-testid="chart-container"
        />
      </div>
    </div>
  );
}
