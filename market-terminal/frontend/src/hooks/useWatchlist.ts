/**
 * Custom hook for managing the watchlist with add/remove operations.
 * Follows the same cancelled-flag pattern as useTickerChart.ts.
 * @generated by code-generator (Agent #19)
 */
import { useEffect, useState } from 'react';
import axios from 'axios';
import type { WatchlistEntry } from '../types/watchlist';
import { SYMBOL_REGEX, MAX_WATCHLIST_SIZE } from '../types/watchlist';
import { getWatchlist, addToWatchlist, removeFromWatchlist } from '../api/client';

export interface UseWatchlistResult {
  readonly entries: WatchlistEntry[];
  readonly count: number;
  readonly maxAllowed: number;
  readonly loading: boolean;
  readonly error: string | null;
  readonly adding: boolean;
  readonly addEntry: (symbol: string, group?: string) => Promise<void>;
  readonly removeEntry: (symbol: string) => Promise<void>;
  readonly refresh: () => void;
}

/**
 * Fetch and manage the watchlist.
 *
 * - Loads the watchlist on mount and whenever refreshKey changes.
 * - Provides addEntry / removeEntry for mutations (re-fetches on success).
 * - Uses static error messages only (XSS prevention -- never reflects user input).
 * - Uses cancelled-flag pattern for cleanup in useEffect.
 */
export function useWatchlist(): UseWatchlistResult {
  const [entries, setEntries] = useState<WatchlistEntry[]>([]);
  const [count, setCount] = useState(0);
  const [maxAllowed, setMaxAllowed] = useState(MAX_WATCHLIST_SIZE);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [adding, setAdding] = useState(false);
  const [refreshKey, setRefreshKey] = useState(0);

  useEffect(() => {
    let cancelled = false;
    setLoading(true);
    setError(null);

    getWatchlist()
      .then((response) => {
        if (cancelled) return;
        setEntries(response.tickers);
        setCount(response.count);
        setMaxAllowed(response.max_allowed);
      })
      .catch(() => {
        if (cancelled) return;
        setError('Failed to load watchlist. Please try again.');
      })
      .finally(() => {
        if (!cancelled) setLoading(false);
      });

    return () => {
      cancelled = true;
    };
  }, [refreshKey]);

  async function addEntry(symbol: string, group?: string): Promise<void> {
    if (adding) return;

    if (!SYMBOL_REGEX.test(symbol)) {
      setError('Invalid ticker symbol format.');
      return;
    }

    if (count >= maxAllowed) {
      setError('Watchlist is full. Remove a ticker first.');
      return;
    }

    setAdding(true);
    setError(null);

    try {
      await addToWatchlist(symbol, group);
      setRefreshKey((k) => k + 1);
    } catch (err: unknown) {
      if (axios.isAxiosError(err)) {
        const status = err.response?.status;
        if (status === 409) {
          setError('Ticker already exists in watchlist.');
        } else if (status === 400) {
          setError('Watchlist is full. Remove a ticker first.');
        } else {
          setError('Failed to add ticker. Please try again.');
        }
      } else {
        setError('Failed to add ticker. Please try again.');
      }
    } finally {
      setAdding(false);
    }
  }

  async function removeEntry(symbol: string): Promise<void> {
    if (!SYMBOL_REGEX.test(symbol)) {
      setError('Invalid ticker symbol format.');
      return;
    }

    setError(null);

    try {
      await removeFromWatchlist(symbol);
      setRefreshKey((k) => k + 1);
    } catch (err: unknown) {
      if (axios.isAxiosError(err) && err.response?.status === 404) {
        setError('Ticker not found in watchlist.');
      } else {
        setError('Failed to remove ticker. Please try again.');
      }
    }
  }

  function refresh(): void {
    setRefreshKey((k) => k + 1);
  }

  return {
    entries,
    count,
    maxAllowed,
    loading,
    error,
    adding,
    addEntry,
    removeEntry,
    refresh,
  };
}
