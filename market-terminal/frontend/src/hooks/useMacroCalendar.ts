/**
 * Custom hooks for fetching macro calendar and reaction data with client-side caching.
 * Follows the same cancelled-flag + AbortController pattern as useAnalysis.ts.
 *
 * @generated by code-generator (Agent #19)
 */
import { useState, useEffect, useCallback, useRef } from 'react';
import { getMacroCalendar, getMacroReaction } from '../api/client';
import type {
  MacroCalendarData,
  MacroCalendarApiResponse,
  MacroReactionData,
  MacroReactionApiResponse,
} from '../types/macro';
import {
  MACRO_CALENDAR_CACHE_TTL_MS,
  MACRO_CALENDAR_PAST_DAYS,
  MACRO_CALENDAR_FUTURE_DAYS,
  MACRO_REACTION_CACHE_TTL_MS,
  normalizeCalendar,
  normalizeReaction,
} from '../types/macro';

// ---------------------------------------------------------------------------
// Cache types
// ---------------------------------------------------------------------------

interface CalendarCacheEntry {
  readonly data: MacroCalendarData;
  readonly timestamp: number;
}

interface ReactionCacheEntry {
  readonly data: MacroReactionData;
  readonly timestamp: number;
}

// ---------------------------------------------------------------------------
// Module-level caches
// ---------------------------------------------------------------------------

/** Module-level cache for calendar data, keyed by date range string. */
const calendarCache = new Map<string, CalendarCacheEntry>();

/** Module-level cache for reaction data, keyed by "SYMBOL:event_type". */
const reactionCache = new Map<string, ReactionCacheEntry>();

// ---------------------------------------------------------------------------
// Date helpers (private)
// ---------------------------------------------------------------------------

/**
 * Format a Date to YYYY-MM-DD string.
 */
function formatDate(date: Date): string {
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, '0');
  const d = String(date.getDate()).padStart(2, '0');
  return `${y}-${m}-${d}`;
}

// ---------------------------------------------------------------------------
// Calendar hook
// ---------------------------------------------------------------------------

export interface UseMacroCalendarResult {
  readonly data: MacroCalendarData | null;
  readonly loading: boolean;
  readonly error: string | null;
}

/**
 * Clear the calendar cache. Useful for testing or force-refresh.
 */
export function clearMacroCalendarCache(): void {
  calendarCache.clear();
}

/**
 * Fetch macro economic calendar data.
 *
 * - Auto-fetches on mount with from_date=today-7d, to_date=today+30d.
 * - Serves from a 5-minute client-side cache when available.
 * - Normalises snake_case backend response to camelCase via normalizeCalendar.
 * - Uses safe static error messages (no XSS -- never reflects user input).
 */
export function useMacroCalendar(): UseMacroCalendarResult {
  const [data, setData] = useState<MacroCalendarData | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const now = new Date();
    const fromDate = new Date(now);
    fromDate.setDate(fromDate.getDate() - MACRO_CALENDAR_PAST_DAYS);
    const toDate = new Date(now);
    toDate.setDate(toDate.getDate() + MACRO_CALENDAR_FUTURE_DAYS);

    const fromStr = formatDate(fromDate);
    const toStr = formatDate(toDate);
    const cacheKey = `${fromStr}:${toStr}`;

    // Check cache first
    const cached = calendarCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < MACRO_CALENDAR_CACHE_TTL_MS) {
      setData(cached.data);
      setError(null);
      setLoading(false);
      return;
    }

    let cancelled = false;
    const controller = new AbortController();
    setLoading(true);
    setError(null);

    getMacroCalendar(
      { from_date: fromStr, to_date: toStr },
      { signal: controller.signal },
    )
      .then((raw: MacroCalendarApiResponse) => {
        if (cancelled) return;

        const normalized = normalizeCalendar(raw);
        calendarCache.set(cacheKey, { data: normalized, timestamp: Date.now() });
        setData(normalized);
        setError(null);
      })
      .catch((err: unknown) => {
        if (cancelled) return;
        // Ignore abort errors -- expected on unmount
        if (err instanceof DOMException && err.name === 'AbortError') return;
        if (
          typeof err === 'object' &&
          err !== null &&
          'code' in err &&
          (err as Record<string, unknown>).code === 'ERR_CANCELED'
        ) {
          return;
        }
        setData(null);
        // Static error message -- NEVER reflect user input (XSS prevention)
        setError('Failed to load calendar data. Please try again later.');
      })
      .finally(() => {
        if (!cancelled) setLoading(false);
      });

    return () => {
      cancelled = true;
      controller.abort();
    };
  }, []);

  return { data, loading, error };
}

// ---------------------------------------------------------------------------
// Reaction hook
// ---------------------------------------------------------------------------

export interface UseMacroReactionResult {
  readonly data: MacroReactionData | null;
  readonly loading: boolean;
  readonly error: string | null;
  readonly fetchReaction: (symbol: string, eventType: string) => void;
}

/**
 * Clear the reaction cache. Useful for testing or force-refresh.
 */
export function clearMacroReactionCache(): void {
  reactionCache.clear();
}

/**
 * Fetch macro reaction data for a given symbol and event type.
 *
 * - On-demand via fetchReaction callback (not auto-fetch).
 * - Serves from a 15-minute client-side cache when available.
 * - Normalises snake_case backend response to camelCase via normalizeReaction.
 * - Uses safe static error messages (no XSS -- never reflects user input).
 */
export function useMacroReaction(): UseMacroReactionResult {
  const [data, setData] = useState<MacroReactionData | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Track the in-flight AbortController so we can cancel on re-fetch or unmount
  const controllerRef = useRef<AbortController | null>(null);

  // Abort any in-flight request on unmount to prevent set-state-after-unmount
  useEffect(() => {
    return () => {
      controllerRef.current?.abort();
    };
  }, []);

  const fetchReaction = useCallback((symbol: string, eventType: string) => {
    // Abort any previous in-flight request to prevent stale-data races
    controllerRef.current?.abort();
    controllerRef.current = null;

    if (!symbol || !eventType) {
      setData(null);
      setError(null);
      setLoading(false);
      return;
    }

    const key = `${symbol.toUpperCase()}:${eventType}`;

    // Check cache first
    const cached = reactionCache.get(key);
    if (cached && Date.now() - cached.timestamp < MACRO_REACTION_CACHE_TTL_MS) {
      setData(cached.data);
      setError(null);
      setLoading(false);
      return;
    }

    const controller = new AbortController();
    controllerRef.current = controller;

    setLoading(true);
    setError(null);

    getMacroReaction(symbol, eventType, { signal: controller.signal })
      .then((raw: MacroReactionApiResponse) => {
        // If this request was aborted (superseded or unmounted), skip state updates
        if (controller.signal.aborted) return;

        const normalized = normalizeReaction(raw);
        reactionCache.set(key, { data: normalized, timestamp: Date.now() });
        setData(normalized);
        setError(null);
      })
      .catch((err: unknown) => {
        // Ignore abort errors -- expected on supersede or unmount
        if (controller.signal.aborted) return;
        if (err instanceof DOMException && err.name === 'AbortError') return;
        if (
          typeof err === 'object' &&
          err !== null &&
          'code' in err &&
          (err as Record<string, unknown>).code === 'ERR_CANCELED'
        ) {
          return;
        }
        setData(null);
        // Static error message -- NEVER reflect user input (XSS prevention)
        setError('Failed to load reaction data. Please try again later.');
      })
      .finally(() => {
        if (!controller.signal.aborted) setLoading(false);
      });
  }, []);

  return { data, loading, error, fetchReaction };
}
