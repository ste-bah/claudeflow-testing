/**
 * Custom hook for fetching fundamentals data with client-side caching.
 * Follows the same cancelled-flag pattern as useTickerChart.ts.
 * @generated by unit-implementer (Agent #21)
 */
import { useState, useEffect } from 'react';
import { getFundamentals, getShortInterest, getAnalystRatings } from '../api/client';
import type {
  FundamentalsData, FundamentalsApiResponse,
  ShortInterest, ShortInterestRaw,
  AnalystRatings, AnalystRatingsRaw
} from '../types/fundamentals';
import {
  FUNDAMENTALS_CACHE_TTL_MS,
  normalizeFundamentals,
  normalizeShortInterest,
  normalizeAnalystRatings
} from '../types/fundamentals';

interface CacheEntry {
  readonly data: FundamentalsData;
  readonly timestamp: number;
}

interface ShortInterestCacheEntry {
  readonly data: ShortInterest | null;
  readonly timestamp: number;
}

interface AnalystRatingsCacheEntry {
  readonly data: AnalystRatings | null;
  readonly timestamp: number;
}

/** Module-level cache keyed by uppercase symbol. */
const cache = new Map<string, CacheEntry>();
const shortInterestCache = new Map<string, ShortInterestCacheEntry>();
const analystRatingsCache = new Map<string, AnalystRatingsCacheEntry>();

export interface UseFundamentalsResult {
  readonly data: FundamentalsData | null;
  readonly shortInterest: ShortInterest | null;
  readonly analystRatings: AnalystRatings | null;
  readonly loading: boolean;
  readonly error: string | null;
}

/**
 * Clear the fundamentals cache. Useful for testing or force-refresh.
 */
export function clearFundamentalsCache(): void {
  cache.clear();
  shortInterestCache.clear();
  analystRatingsCache.clear();
}

/**
 * Fetch fundamentals data for a given symbol.
 *
 * - Returns null data when symbol is empty (no fetch).
 * - Serves from a 15-minute client-side cache when available.
 * - Normalises snake_case backend response to camelCase via normalizeFundamentals.
 * - Uses safe static error messages (no XSS -- never reflects user input).
 * - No auto-retry on failure.
 *
 * @param symbol - Ticker symbol (e.g. "AAPL")
 */
export function useFundamentals(symbol: string): UseFundamentalsResult {
  const [data, setData] = useState<FundamentalsData | null>(null);
  const [shortInterest, setShortInterest] = useState<ShortInterest | null>(null);
  const [analystRatings, setAnalystRatings] = useState<AnalystRatings | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!symbol) {
      setData(null);
      setShortInterest(null);
      setAnalystRatings(null);
      setError(null);
      setLoading(false);
      return;
    }

    const key = symbol.toUpperCase();
    let cancelled = false;
    setLoading(true);
    setError(null);

    const checkCache = () => {
      // Fundamentals cache check
      const cachedFund = cache.get(key);
      if (cachedFund && Date.now() - cachedFund.timestamp < FUNDAMENTALS_CACHE_TTL_MS) {
        setData(cachedFund.data);
      }

      // Short interest cache check (24h)
      const cachedSI = shortInterestCache.get(key);
      if (cachedSI && Date.now() - cachedSI.timestamp < 86400000) {
        setShortInterest(cachedSI.data);
      }

      // Ratings cache check (24h)
      const cachedAR = analystRatingsCache.get(key);
      if (cachedAR && Date.now() - cachedAR.timestamp < 86400000) {
        setAnalystRatings(cachedAR.data);
      }

      return !!cachedFund && !!cachedSI && !!cachedAR;
    };

    if (checkCache()) {
      setLoading(false);
      return;
    }

    // Promise orchestration
    const fetchCore = !cache.has(key) ? getFundamentals(key).then((raw: FundamentalsApiResponse) => {
      if (cancelled) return;
      const normalized = normalizeFundamentals(raw);
      cache.set(key, { data: normalized, timestamp: Date.now() });
      setData(normalized);
    }) : Promise.resolve();

    const fetchSI = !shortInterestCache.has(key) ? getShortInterest(key).then(response => {
      if (cancelled) return;
      const normalized = response.data ? normalizeShortInterest(response.data as ShortInterestRaw) : null;
      shortInterestCache.set(key, { data: normalized, timestamp: Date.now() });
      setShortInterest(normalized);
    }).catch(() => {
      if (!cancelled) {
        setShortInterest(null);
        shortInterestCache.set(key, { data: null, timestamp: Date.now() }); // Cache graceful degradation 
      }
    }) : Promise.resolve();

    const fetchAR = !analystRatingsCache.has(key) ? getAnalystRatings(key).then(response => {
      if (cancelled) return;
      const normalized = response.data ? normalizeAnalystRatings(response.data as AnalystRatingsRaw) : null;
      analystRatingsCache.set(key, { data: normalized, timestamp: Date.now() });
      setAnalystRatings(normalized);
    }).catch(() => {
      if (!cancelled) {
        setAnalystRatings(null);
        analystRatingsCache.set(key, { data: null, timestamp: Date.now() }); // Cache graceful degradation
      }
    }) : Promise.resolve();

    Promise.all([fetchCore, fetchSI, fetchAR])
      .then(() => {
        if (!cancelled) setError(null);
      })
      .catch(() => {
        if (cancelled) return;
        setData(null);
        setError('Failed to load fundamentals data. Please try again later.');
      })
      .finally(() => {
        if (!cancelled) setLoading(false);
      });

    return () => {
      cancelled = true;
    };
  }, [symbol]);

  return { data, shortInterest, analystRatings, loading, error };
}
