/**
 * Custom hook for fetching paginated news articles with client-side caching.
 * Follows the same cancelled-flag pattern as useTickerChart.ts.
 * @generated by code-generator (Agent #19)
 */
import { useCallback, useEffect, useRef, useState } from 'react';
import type { NewsArticle } from '../types/news';
import {
  NEWS_CACHE_TTL_MS,
  NEWS_PAGE_SIZE,
  NEWS_RETRY_DELAY_MS,
  normalizeArticle,
  sortArticlesByDate,
} from '../types/news';
import { getNews } from '../api/client';

// ---------------------------------------------------------------------------
// Cache
// ---------------------------------------------------------------------------

interface CacheEntry {
  readonly articles: NewsArticle[];
  readonly totalCount: number;
  readonly timestamp: number;
}

/** Module-level cache keyed by uppercase symbol. Stores page-1 results only. */
const cache = new Map<string, CacheEntry>();

// ---------------------------------------------------------------------------
// Result interface
// ---------------------------------------------------------------------------

export interface UseNewsFeedResult {
  readonly articles: NewsArticle[];
  readonly totalCount: number;
  readonly hasMore: boolean;
  readonly loading: boolean;
  readonly loadingMore: boolean;
  readonly error: string | null;
  readonly loadMore: () => void;
}

// ---------------------------------------------------------------------------
// Hook
// ---------------------------------------------------------------------------

/**
 * Fetch paginated news articles for a given symbol.
 *
 * - Returns empty state when symbol is empty (no fetch).
 * - Serves page-1 from a 5-minute client-side cache when available.
 * - Uses normalizeArticle to convert raw backend articles.
 * - Uses safe static error messages (never reflects user input -- XSS prevention).
 * - Auto-retries on error after 5 seconds.
 *
 * @param symbol - Uppercase ticker symbol
 */
export function useNewsFeed(symbol: string): UseNewsFeedResult {
  const [articles, setArticles] = useState<NewsArticle[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const [loading, setLoading] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Track the current offset for pagination.
  const offsetRef = useRef(0);

  // Mirror totalCount in a ref so loadMore can read a stable value without
  // needing totalCount in its dependency array.
  const totalCountRef = useRef(0);

  // Track the active symbol so loadMore can detect stale responses.
  const activeSymbolRef = useRef(symbol);

  // Track the retry timer so we can clear it on cleanup.
  const retryTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  // -----------------------------------------------------------------------
  // Shared helper: fetch page-1, normalise, cache, and apply to state.
  // Extracted to eliminate duplication between the initial fetch and the
  // retry path.
  // -----------------------------------------------------------------------

  /**
   * Fetch the first page of news for `fetchSymbol`, normalise the response,
   * populate the module-level cache, and update React state.
   *
   * @returns The fetch promise (caller chains `.catch` / `.finally` on it).
   */
  function fetchNormaliseCachePage1(
    fetchSymbol: string,
    cacheKey: string,
    cancelled: () => boolean,
  ): Promise<void> {
    return getNews(fetchSymbol, { limit: NEWS_PAGE_SIZE, offset: 0 }).then(
      (response) => {
        if (cancelled()) return;

        const normalised = sortArticlesByDate(
          Array.isArray(response.articles)
            ? response.articles
                .map(normalizeArticle)
                .filter((a): a is NewsArticle => a !== null)
            : [],
        );

        cache.set(cacheKey, {
          articles: normalised,
          totalCount: response.total_count,
          timestamp: Date.now(),
        });

        setArticles(normalised);
        setTotalCount(response.total_count);
        totalCountRef.current = response.total_count;
        offsetRef.current = normalised.length;
      },
    );
  }

  // -----------------------------------------------------------------------
  // Initial fetch (page 1) -- triggers on symbol change
  // -----------------------------------------------------------------------

  useEffect(() => {
    // Keep the active symbol in sync for loadMore staleness checks.
    activeSymbolRef.current = symbol;

    // Clear any pending retry from a previous symbol.
    if (retryTimerRef.current !== null) {
      clearTimeout(retryTimerRef.current);
      retryTimerRef.current = null;
    }

    if (!symbol) {
      setArticles([]);
      setTotalCount(0);
      totalCountRef.current = 0;
      setError(null);
      setLoading(false);
      setLoadingMore(false);
      offsetRef.current = 0;
      return;
    }

    const cacheKey = symbol.toUpperCase();
    const cached = cache.get(cacheKey);
    const now = Date.now();

    if (cached && now - cached.timestamp < NEWS_CACHE_TTL_MS) {
      setArticles(cached.articles);
      setTotalCount(cached.totalCount);
      totalCountRef.current = cached.totalCount;
      setError(null);
      setLoading(false);
      setLoadingMore(false);
      offsetRef.current = cached.articles.length;
      return;
    }

    let cancelled = false;
    const isCancelled = () => cancelled;

    setLoading(true);
    setError(null);
    setArticles([]);
    setTotalCount(0);
    totalCountRef.current = 0;
    offsetRef.current = 0;

    fetchNormaliseCachePage1(symbol, cacheKey, isCancelled)
      .catch(() => {
        if (cancelled) return;
        setError('Failed to load news. Retrying...');

        // Auto-retry after delay.
        retryTimerRef.current = setTimeout(() => {
          if (!cancelled) {
            retryTimerRef.current = null;
            cache.delete(cacheKey);
            setError(null);
            setLoading(true);

            fetchNormaliseCachePage1(symbol, cacheKey, isCancelled)
              .catch(() => {
                if (!cancelled) {
                  setError('Failed to load news. Please try again later.');
                }
              })
              .finally(() => {
                if (!cancelled) setLoading(false);
              });
          }
        }, NEWS_RETRY_DELAY_MS);
      })
      .finally(() => {
        if (!cancelled) setLoading(false);
      });

    return () => {
      cancelled = true;
      if (retryTimerRef.current !== null) {
        clearTimeout(retryTimerRef.current);
        retryTimerRef.current = null;
      }
    };
  }, [symbol]);

  // -----------------------------------------------------------------------
  // Load more (next page)
  // -----------------------------------------------------------------------

  const loadMore = useCallback(() => {
    if (!symbol || loading || loadingMore) return;
    if (offsetRef.current >= totalCountRef.current) return;

    setLoadingMore(true);
    setError(null);

    const currentOffset = offsetRef.current;

    // Capture the symbol at call time so we can detect stale responses.
    // If the user changes symbols while this request is in-flight,
    // activeSymbolRef will have been updated and we discard the result.
    const requestSymbol = symbol;

    getNews(symbol, { limit: NEWS_PAGE_SIZE, offset: currentOffset })
      .then((response) => {
        // Discard if the active symbol changed while the request was in-flight.
        if (activeSymbolRef.current !== requestSymbol) return;

        const normalised = sortArticlesByDate(
          Array.isArray(response.articles)
            ? response.articles
                .map(normalizeArticle)
                .filter((a): a is NewsArticle => a !== null)
            : [],
        );

        setArticles((prev) => [...prev, ...normalised]);
        setTotalCount(response.total_count);
        totalCountRef.current = response.total_count;
        offsetRef.current = currentOffset + normalised.length;
      })
      .catch(() => {
        if (activeSymbolRef.current !== requestSymbol) return;
        setError('Failed to load more articles. Please try again.');
      })
      .finally(() => {
        if (activeSymbolRef.current === requestSymbol) {
          setLoadingMore(false);
        }
      });
  }, [symbol, loading, loadingMore]);

  const hasMore = articles.length < totalCount;

  return {
    articles,
    totalCount,
    hasMore,
    loading,
    loadingMore,
    error,
    loadMore,
  };
}

/**
 * Clear the news feed cache. Useful for testing or force-refresh.
 */
export function clearNewsFeedCache(): void {
  cache.clear();
}
