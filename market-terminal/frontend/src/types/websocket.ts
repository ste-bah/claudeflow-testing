/**
 * WebSocket message types, constants, and type guards.
 * Wire-format uses snake_case to match the Python backend.
 * @generated by code-generator (Agent #19)
 */

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

/** Available WebSocket subscription channels. */
export const WS_CHANNELS = {
  PriceUpdates: 'price_updates',
  AnalysisProgress: 'analysis_progress',
  NewsAlerts: 'news_alerts',
} as const;

/** Default reconnection / keep-alive parameters. */
export const WS_DEFAULTS = {
  reconnectDelayMs: 1_000,
  maxReconnectDelayMs: 30_000,
  reconnectMultiplier: 2,
  maxReconnectAttempts: 10,
  pingIntervalMs: 25_000,
} as const;

// ---------------------------------------------------------------------------
// Derived helper types
// ---------------------------------------------------------------------------

/** One of the known channel identifiers. */
export type WsChannel = (typeof WS_CHANNELS)[keyof typeof WS_CHANNELS];

/** Lifecycle status of the client WebSocket connection. */
export type WsConnectionStatus =
  | 'disconnected'
  | 'connecting'
  | 'connected'
  | 'reconnecting';

// ---------------------------------------------------------------------------
// Server → Client message interfaces (discriminated on `type`)
// ---------------------------------------------------------------------------

export interface WsConnectedMessage {
  readonly type: 'connected';
  readonly client_id: string;
  readonly server_time: string;
  readonly reconnect_hint: {
    readonly strategy: 'exponential_backoff';
    readonly initial_delay_ms: number;
    readonly max_delay_ms: number;
    readonly multiplier: number;
  };
}

export interface WsSubscribedMessage {
  readonly type: 'subscribed';
  readonly channel: string;
}

export interface WsUnsubscribedMessage {
  readonly type: 'unsubscribed';
  readonly channel: string;
}

export interface WsHeartbeatMessage {
  readonly type: 'heartbeat';
  readonly server_time: string;
}

export interface WsPongMessage {
  readonly type: 'pong';
}

export interface WsAckMessage {
  readonly type: 'ack';
}

export interface WsErrorMessage {
  readonly type: 'error';
  readonly source: string;
  readonly message: string;
  readonly severity: 'warning' | 'error';
}

export interface WsPriceUpdateMessage {
  readonly type: 'price_update';
  readonly symbol: string;
  readonly price: number;
  readonly change_percent: number;
  readonly timestamp: string;
}

export interface WsAnalysisProgressMessage {
  readonly type: 'analysis_progress';
  readonly symbol: string;
  readonly agent: string;
  readonly agent_number: number;
  readonly total_agents: number;
  readonly status: 'running' | 'completed' | 'failed';
  readonly message: string;
}

export interface WsAnalysisCompleteMessage {
  readonly type: 'analysis_complete';
  readonly symbol: string;
  readonly composite_signal: {
    readonly direction: string;
    readonly score: number;
  };
  readonly timestamp: string;
}

export interface WsNewsAlertMessage {
  readonly type: 'news_alert';
  readonly symbol: string;
  readonly headline: string;
  readonly sentiment: {
    readonly score: number;
    readonly label: string;
  };
  readonly timestamp: string;
}

export interface WsGodAgentProgressMessage {
  readonly type: 'god_agent_progress';
  readonly ticker: string | null;
  readonly agent_current: number;
  readonly agent_total: number;
  readonly message: string;
}

export interface WsGodAgentCompleteMessage {
  readonly type: 'god_agent_complete';
  readonly ticker: string | null;
  readonly status: 'success' | 'error' | 'timeout' | 'busy' | 'cancelled';
  readonly execution_time_ms: number;
  readonly agent_count: number;
}

// ---------------------------------------------------------------------------
// Cancel query response (POST /api/query/cancel)
// ---------------------------------------------------------------------------

export interface CancelQueryResponse {
  readonly cancelled: boolean;
}

// ---------------------------------------------------------------------------
// Union types
// ---------------------------------------------------------------------------

/** Discriminated union of every message the server can send. */
export type WsServerMessage =
  | WsConnectedMessage
  | WsSubscribedMessage
  | WsUnsubscribedMessage
  | WsHeartbeatMessage
  | WsPongMessage
  | WsAckMessage
  | WsErrorMessage
  | WsPriceUpdateMessage
  | WsAnalysisProgressMessage
  | WsAnalysisCompleteMessage
  | WsNewsAlertMessage
  | WsGodAgentProgressMessage
  | WsGodAgentCompleteMessage;

/** String-literal union of every server message `type` value. */
export type WsServerMessageType = WsServerMessage['type'];

/** Maps each `type` string to its corresponding interface. */
export type WsMessageMap = {
  connected: WsConnectedMessage;
  subscribed: WsSubscribedMessage;
  unsubscribed: WsUnsubscribedMessage;
  heartbeat: WsHeartbeatMessage;
  pong: WsPongMessage;
  ack: WsAckMessage;
  error: WsErrorMessage;
  price_update: WsPriceUpdateMessage;
  analysis_progress: WsAnalysisProgressMessage;
  analysis_complete: WsAnalysisCompleteMessage;
  news_alert: WsNewsAlertMessage;
  god_agent_progress: WsGodAgentProgressMessage;
  god_agent_complete: WsGodAgentCompleteMessage;
};

// ---------------------------------------------------------------------------
// Client → Server action interfaces (discriminated on `action`)
// ---------------------------------------------------------------------------

export interface WsSubscribeAction {
  readonly action: 'subscribe';
  readonly channel: string;
}

export interface WsUnsubscribeAction {
  readonly action: 'unsubscribe';
  readonly channel: string;
}

export interface WsPingAction {
  readonly action: 'ping';
}

/** Discriminated union of every action the client can send. */
export type WsClientAction =
  | WsSubscribeAction
  | WsUnsubscribeAction
  | WsPingAction;

// ---------------------------------------------------------------------------
// Type guards
// ---------------------------------------------------------------------------

/** Set of all valid `type` values for O(1) membership checks. */
const VALID_TYPES: ReadonlySet<string> = new Set<WsServerMessageType>([
  'connected',
  'subscribed',
  'unsubscribed',
  'heartbeat',
  'pong',
  'ack',
  'error',
  'price_update',
  'analysis_progress',
  'analysis_complete',
  'news_alert',
  'god_agent_progress',
  'god_agent_complete',
]);

/** Returns `true` if `data` looks like a valid server message. */
export function isServerMessage(data: unknown): data is WsServerMessage {
  if (data === null || typeof data !== 'object') return false;
  const obj = data as Record<string, unknown>;
  return typeof obj.type === 'string' && VALID_TYPES.has(obj.type);
}

/** Narrows to {@link WsConnectedMessage}. */
export function isConnected(msg: WsServerMessage): msg is WsConnectedMessage {
  return (
    msg.type === 'connected' &&
    typeof (msg as WsConnectedMessage).client_id === 'string' &&
    typeof (msg as WsConnectedMessage).server_time === 'string'
  );
}

/** Narrows to {@link WsHeartbeatMessage}. */
export function isHeartbeat(msg: WsServerMessage): msg is WsHeartbeatMessage {
  return (
    msg.type === 'heartbeat' &&
    typeof (msg as WsHeartbeatMessage).server_time === 'string'
  );
}

/** Narrows to {@link WsErrorMessage}. */
export function isError(msg: WsServerMessage): msg is WsErrorMessage {
  return (
    msg.type === 'error' &&
    typeof (msg as WsErrorMessage).source === 'string' &&
    typeof (msg as WsErrorMessage).message === 'string'
  );
}

/** Narrows to {@link WsPriceUpdateMessage}. */
export function isPriceUpdate(
  msg: WsServerMessage,
): msg is WsPriceUpdateMessage {
  const m = msg as WsPriceUpdateMessage;
  return (
    msg.type === 'price_update' &&
    typeof m.symbol === 'string' &&
    Number.isFinite(m.price) &&
    Number.isFinite(m.change_percent) &&
    typeof m.timestamp === 'string'
  );
}

/** Narrows to {@link WsAnalysisProgressMessage}. */
export function isAnalysisProgress(
  msg: WsServerMessage,
): msg is WsAnalysisProgressMessage {
  const m = msg as WsAnalysisProgressMessage;
  return (
    msg.type === 'analysis_progress' &&
    typeof m.symbol === 'string' &&
    typeof m.agent === 'string' &&
    Number.isFinite(m.agent_number) &&
    Number.isFinite(m.total_agents) &&
    typeof m.status === 'string' &&
    typeof m.message === 'string'
  );
}

/** Narrows to {@link WsAnalysisCompleteMessage}. */
export function isAnalysisComplete(
  msg: WsServerMessage,
): msg is WsAnalysisCompleteMessage {
  const m = msg as WsAnalysisCompleteMessage;
  return (
    msg.type === 'analysis_complete' &&
    typeof m.symbol === 'string' &&
    m.composite_signal !== null &&
    typeof m.composite_signal === 'object' &&
    typeof m.composite_signal.direction === 'string' &&
    Number.isFinite(m.composite_signal.score) &&
    typeof m.timestamp === 'string'
  );
}

/** Narrows to {@link WsNewsAlertMessage}. */
export function isNewsAlert(
  msg: WsServerMessage,
): msg is WsNewsAlertMessage {
  const m = msg as WsNewsAlertMessage;
  return (
    msg.type === 'news_alert' &&
    typeof m.symbol === 'string' &&
    typeof m.headline === 'string' &&
    m.sentiment !== null &&
    typeof m.sentiment === 'object' &&
    Number.isFinite(m.sentiment.score) &&
    typeof m.sentiment.label === 'string' &&
    typeof m.timestamp === 'string'
  );
}

/** Narrows to {@link WsGodAgentProgressMessage}. */
export function isGodAgentProgress(
  msg: WsServerMessage,
): msg is WsGodAgentProgressMessage {
  const m = msg as WsGodAgentProgressMessage;
  return (
    msg.type === 'god_agent_progress' &&
    (m.ticker === null || typeof m.ticker === 'string') &&
    Number.isFinite(m.agent_current) &&
    Number.isFinite(m.agent_total) &&
    typeof m.message === 'string'
  );
}

/** Narrows to {@link WsGodAgentCompleteMessage}. */
export function isGodAgentComplete(
  msg: WsServerMessage,
): msg is WsGodAgentCompleteMessage {
  const m = msg as WsGodAgentCompleteMessage;
  return (
    msg.type === 'god_agent_complete' &&
    (m.ticker === null || typeof m.ticker === 'string') &&
    typeof m.status === 'string' &&
    Number.isFinite(m.execution_time_ms) &&
    Number.isFinite(m.agent_count)
  );
}
