/**
 * Command Bar types, constants, parser, and utilities.
 *
 * All pure functions -- zero imports, zero side effects, never throws.
 * The parseCommand function is the single entry point for transforming
 * raw user input into a typed ParsedCommand discriminated union.
 *
 * @generated by type-implementer (Agent #20)
 */

// ---------------------------------------------------------------------------
// Type literal unions
// ---------------------------------------------------------------------------

export type CommandType =
  | 'ticker'
  | 'analyze'
  | 'watch_add'
  | 'watch_remove'
  | 'news'
  | 'scan'
  | 'fundamentals'
  | 'insider'
  | 'macro'
  | 'query';

// ---------------------------------------------------------------------------
// Discriminated union: ParsedCommand
// ---------------------------------------------------------------------------

/** A command that targets a specific ticker symbol. */
export interface SymbolCommand {
  readonly type: 'ticker' | 'analyze' | 'watch_add' | 'watch_remove' | 'news' | 'fundamentals' | 'insider';
  readonly symbol: string;
  readonly raw: string;
}

/** A scan/screening command with an optional preset filter. */
export interface ScanCommand {
  readonly type: 'scan';
  readonly preset: 'bullish' | 'bearish' | 'strong' | null;
  readonly raw: string;
}

/** A macro calendar command. */
export interface MacroCommand {
  readonly type: 'macro';
  readonly raw: string;
}

/** A free-text query command (fallback). */
export interface QueryCommand {
  readonly type: 'query';
  readonly text: string;
  readonly raw: string;
}

export type ParsedCommand = SymbolCommand | ScanCommand | MacroCommand | QueryCommand;

// ---------------------------------------------------------------------------
// Result types
// ---------------------------------------------------------------------------

/** The result of executing a parsed command. */
export interface CommandResult {
  readonly command: ParsedCommand;
  readonly data: Record<string, unknown> | null;
  readonly error: string | null;
  readonly timestamp: number;
}

/** A suggestion shown in the command bar autocomplete dropdown. */
export interface CommandSuggestion {
  readonly label: string;
  readonly description: string;
  readonly value: string;
  readonly type: CommandType;
}

// ---------------------------------------------------------------------------
// Wire type (matches backend scan endpoint)
// ---------------------------------------------------------------------------

/** Response envelope from GET /api/scan. */
export interface ScanApiResponse {
  readonly query: Record<string, unknown>;
  readonly results: readonly Record<string, unknown>[];
  readonly total_matches: number;
  readonly total_scanned: number;
  readonly scan_duration_ms: number;
  readonly note: string;
}

// ---------------------------------------------------------------------------
// Hook return type
// ---------------------------------------------------------------------------

/** Return type for the useCommand hook. */
export interface UseCommandResult {
  readonly result: CommandResult | null;
  readonly loading: boolean;
  readonly error: string | null;
  readonly execute: (raw: string) => void;
  readonly historyBack: () => string | null;
  readonly historyForward: () => string | null;
  readonly clearResult: () => void;
}

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

/** Valid ticker symbol pattern: 1-5 uppercase letters. Applied AFTER toUpperCase(). */
export const COMMAND_SYMBOL_REGEX = /^[A-Z]{1,5}$/;

/** Maximum number of entries retained in command history. */
export const MAX_HISTORY = 50;

/** Maximum allowed length for raw command input (after sanitisation). */
export const MAX_INPUT_LENGTH = 500;

/**
 * Static suggestion list. The placeholder `{symbol}` is replaced at filter
 * time with the active ticker.
 */
export const COMMAND_SUGGESTIONS: readonly CommandSuggestion[] = [
  { label: 'analyze {symbol}', description: 'Run full analysis pipeline', value: 'analyze ', type: 'analyze' },
  { label: 'news {symbol}', description: 'View latest news', value: 'news ', type: 'news' },
  { label: 'fundamentals {symbol}', description: 'View fundamental data', value: 'fundamentals ', type: 'fundamentals' },
  { label: 'insider {symbol}', description: 'View insider activity', value: 'insider ', type: 'insider' },
  { label: 'watch add {symbol}', description: 'Add to watchlist', value: 'watch add ', type: 'watch_add' },
  { label: 'watch remove {symbol}', description: 'Remove from watchlist', value: 'watch remove ', type: 'watch_remove' },
  { label: 'scan', description: 'Scan all stocks', value: 'scan', type: 'scan' },
  { label: 'scan bullish', description: 'Scan for bullish signals', value: 'scan bullish', type: 'scan' },
  { label: 'macro', description: 'View macro calendar', value: 'macro', type: 'macro' },
] as const;

// ---------------------------------------------------------------------------
// Validation sets (private)
// ---------------------------------------------------------------------------

const VALID_SCAN_PRESETS: ReadonlySet<string> = new Set(['bullish', 'bearish', 'strong']);

// ---------------------------------------------------------------------------
// Pure functions (zero imports, zero side effects, never throws)
// ---------------------------------------------------------------------------

/**
 * Sanitise raw user input by stripping dangerous characters, trimming
 * whitespace, and enforcing the maximum input length.
 *
 * Strips: < > & " '
 */
export function sanitize(raw: string): string {
  return raw
    .replace(/[<>&"']/g, '')
    .trim()
    .slice(0, MAX_INPUT_LENGTH);
}

/**
 * Parse raw user input into a typed command.
 *
 * 4-tier precedence:
 *   1. Two/three-word prefix commands: analyze X, watch add/remove X, news X,
 *      fundamentals X, insider X
 *   2. One-word + optional args: scan [bullish|bearish|strong]
 *   3. Single keyword: macro
 *   4. Fallback: symbol regex match -> ticker, else -> query
 *
 * Pure function: zero imports, zero side effects, never throws.
 */
export function parseCommand(raw: string): ParsedCommand {
  const sanitized = sanitize(raw);

  if (sanitized === '') {
    return { type: 'query', text: '', raw: sanitized };
  }

  const words = sanitized.split(/\s+/);
  const first = words[0].toLowerCase();

  // -- Tier 1: two/three-word prefix commands --------------------------------

  if (first === 'analyze' && words.length >= 2) {
    const candidate = words[1].toUpperCase();
    if (COMMAND_SYMBOL_REGEX.test(candidate)) {
      return { type: 'analyze', symbol: candidate, raw: sanitized };
    }
  }

  if (first === 'watch' && words.length >= 3) {
    const sub = words[1].toLowerCase();
    const candidate = words[2].toUpperCase();
    if (sub === 'add' && COMMAND_SYMBOL_REGEX.test(candidate)) {
      return { type: 'watch_add', symbol: candidate, raw: sanitized };
    }
    if (sub === 'remove' && COMMAND_SYMBOL_REGEX.test(candidate)) {
      return { type: 'watch_remove', symbol: candidate, raw: sanitized };
    }
  }

  if (first === 'news' && words.length >= 2) {
    const candidate = words[1].toUpperCase();
    if (COMMAND_SYMBOL_REGEX.test(candidate)) {
      return { type: 'news', symbol: candidate, raw: sanitized };
    }
  }

  if (first === 'fundamentals' && words.length >= 2) {
    const candidate = words[1].toUpperCase();
    if (COMMAND_SYMBOL_REGEX.test(candidate)) {
      return { type: 'fundamentals', symbol: candidate, raw: sanitized };
    }
  }

  if (first === 'insider' && words.length >= 2) {
    const candidate = words[1].toUpperCase();
    if (COMMAND_SYMBOL_REGEX.test(candidate)) {
      return { type: 'insider', symbol: candidate, raw: sanitized };
    }
  }

  // -- Tier 2: one-word + optional arg commands ------------------------------

  if (first === 'scan') {
    let preset: 'bullish' | 'bearish' | 'strong' | null = null;
    if (words.length >= 2 && VALID_SCAN_PRESETS.has(words[1].toLowerCase())) {
      preset = words[1].toLowerCase() as 'bullish' | 'bearish' | 'strong';
    }
    return { type: 'scan', preset, raw: sanitized };
  }

  // -- Tier 3: single keyword commands ---------------------------------------

  if (first === 'macro') {
    return { type: 'macro', raw: sanitized };
  }

  // -- Tier 4: bare symbol / free-text fallback ------------------------------

  const upper = sanitized.toUpperCase();
  if (COMMAND_SYMBOL_REGEX.test(upper)) {
    return { type: 'ticker', symbol: upper, raw: sanitized };
  }

  return { type: 'query', text: sanitized, raw: sanitized };
}

// ---------------------------------------------------------------------------
// Suggestion filtering
// ---------------------------------------------------------------------------

/**
 * Filter the static COMMAND_SUGGESTIONS list based on current input.
 *
 * - Returns empty array when input is empty.
 * - Matches suggestions whose label starts with the input (case-insensitive).
 * - Replaces `{symbol}` placeholders with activeTicker when available.
 * - Returns at most `limit` results (default 8).
 */
export function filterSuggestions(
  input: string,
  activeTicker: string,
  limit: number = 8,
): CommandSuggestion[] {
  if (input === '') {
    return [];
  }

  const lower = input.toLowerCase();

  return COMMAND_SUGGESTIONS
    .filter((s) => s.label.toLowerCase().startsWith(lower))
    .map((s) => {
      if (activeTicker) {
        return {
          label: s.label.replace('{symbol}', activeTicker),
          description: s.description,
          value: s.value.replace('{symbol}', activeTicker),
          type: s.type,
        };
      }
      return { label: s.label, description: s.description, value: s.value, type: s.type };
    })
    .slice(0, limit);
}

// ---------------------------------------------------------------------------
// Color mapping
// ---------------------------------------------------------------------------

/**
 * Map a CommandType to its corresponding Tailwind text color class.
 */
export function commandTypeColor(type: CommandType): string {
  switch (type) {
    case 'ticker':
      return 'text-accent-blue';
    case 'analyze':
      return 'text-accent-green';
    case 'watch_add':
      return 'text-green-400';
    case 'watch_remove':
      return 'text-red-400';
    case 'news':
      return 'text-accent-amber';
    case 'scan':
      return 'text-purple-400';
    case 'fundamentals':
      return 'text-cyan-400';
    case 'insider':
      return 'text-orange-400';
    case 'macro':
      return 'text-yellow-400';
    case 'query':
      return 'text-text-secondary';
    default:
      return 'text-text-secondary';
  }
}

// ---------------------------------------------------------------------------
// Type guards
// ---------------------------------------------------------------------------

/** Narrow a ParsedCommand to SymbolCommand. */
export function isSymbolCommand(cmd: ParsedCommand): cmd is SymbolCommand {
  return 'symbol' in cmd;
}

/** Narrow a ParsedCommand to ScanCommand. */
export function isScanCommand(cmd: ParsedCommand): cmd is ScanCommand {
  return cmd.type === 'scan';
}

/** Narrow a ParsedCommand to MacroCommand. */
export function isMacroCommand(cmd: ParsedCommand): cmd is MacroCommand {
  return cmd.type === 'macro';
}

/** Narrow a ParsedCommand to QueryCommand. */
export function isQueryCommand(cmd: ParsedCommand): cmd is QueryCommand {
  return cmd.type === 'query';
}
