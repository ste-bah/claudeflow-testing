/**
 * Analysis types, constants, validation, and normalizers for the
 * MethodologyScores panel and analysis-related components.
 *
 * Wire-format types match the backend /api/analysis/{symbol} response exactly.
 * Display types use camelCase for React component consumption.
 *
 * @generated by code-generator (Agent #19)
 */

// ---------------------------------------------------------------------------
// Type literal unions
// ---------------------------------------------------------------------------

export type OverallDirection =
  | 'strong_bullish'
  | 'bullish'
  | 'neutral'
  | 'bearish'
  | 'strong_bearish';

export type SignalDirection = 'bullish' | 'bearish' | 'neutral';

export type SignalTimeframe = 'short' | 'medium' | 'long';

// ---------------------------------------------------------------------------
// Wire-format types (snake_case -- matches backend response)
// ---------------------------------------------------------------------------

/** Single methodology signal as returned by the backend. */
export interface AnalysisSignalRaw {
  readonly ticker: string;
  readonly methodology: string;
  readonly direction: string;
  readonly confidence: number;
  readonly timeframe: string;
  readonly reasoning: string;
  readonly key_levels: Record<string, unknown>;
  readonly timestamp: string;
}

/** Timeframe breakdown entry as returned by the backend. */
export interface TimeframeBreakdownRaw {
  readonly direction: string;
  readonly confidence: number;
  readonly methodologies: string[];
}

/** Composite analysis result as returned by the backend. */
export interface AnalysisCompositeRaw {
  readonly overall_direction: string;
  readonly overall_confidence: number;
  readonly confluence_count: number;
  readonly timeframe_breakdown: Record<string, TimeframeBreakdownRaw>;
  readonly trade_thesis: string;
  readonly weights_used: Record<string, number>;
  readonly timestamp: string;
}

/** Analysis metadata as returned by the backend. */
export interface AnalysisMetadataRaw {
  readonly analysis_duration_ms: number;
  readonly methodologies_requested: number;
  readonly methodologies_completed: number;
  readonly methodologies_failed: number;
  readonly failed_methodologies: string[];
  readonly cached: boolean;
  readonly data_sources_used: string[];
}

/** Full envelope response from GET /api/analysis/{symbol}. */
export interface AnalysisApiResponse {
  readonly symbol: string;
  readonly composite: AnalysisCompositeRaw;
  readonly signals: AnalysisSignalRaw[];
  readonly metadata: AnalysisMetadataRaw;
}

// ---------------------------------------------------------------------------
// Display types (camelCase -- for React components)
// ---------------------------------------------------------------------------

/** Normalised methodology signal ready for rendering. */
export interface AnalysisSignal {
  readonly ticker: string;
  readonly methodology: string;
  readonly direction: SignalDirection;
  readonly confidence: number;
  readonly timeframe: SignalTimeframe;
  readonly reasoning: string;
  readonly keyLevels: Record<string, unknown>;
  readonly timestamp: string;
}

/** Normalised timeframe breakdown ready for rendering. */
export interface TimeframeBreakdown {
  readonly direction: SignalDirection;
  readonly confidence: number;
  readonly methodologies: string[];
}

/** Normalised composite analysis result ready for rendering. */
export interface AnalysisComposite {
  readonly overallDirection: OverallDirection;
  readonly overallConfidence: number;
  readonly confluenceCount: number;
  readonly timeframeBreakdown: Record<SignalTimeframe, TimeframeBreakdown>;
  readonly tradeThesis: string;
  readonly weightsUsed: Record<string, number>;
  readonly timestamp: string;
}

/** Normalised analysis metadata ready for rendering. */
export interface AnalysisMetadata {
  readonly analysisDurationMs: number;
  readonly methodologiesRequested: number;
  readonly methodologiesCompleted: number;
  readonly methodologiesFailed: number;
  readonly failedMethodologies: string[];
  readonly cached: boolean;
  readonly dataSourcesUsed: string[];
}

/** Normalised analysis data ready for rendering. */
export interface AnalysisData {
  readonly symbol: string;
  readonly composite: AnalysisComposite;
  readonly signals: AnalysisSignal[];
  readonly metadata: AnalysisMetadata;
}

/** A single turning point in an Elliott Wave count, used to draw the overlay. */
export interface EWavePoint {
  readonly time: string;   // ISO date/datetime string matching chart bar format
  readonly price: number;
  readonly label: string;  // '0','1','2','3','4','5' or 'A','B','C'
}

/** A single Fibonacci level from the Elliott Wave analysis. */
export interface EFibLevel {
  readonly ratio: number;
  readonly price: number;
  readonly label: string;
  readonly aligned: boolean;
  readonly type: 'retracement' | 'extension';
}

/** All Elliott Wave overlay data extracted from the elliott_wave key_levels. */
export interface EWaveOverlayData {
  readonly wavePoints: EWavePoint[];
  readonly fibLevels: EFibLevel[];
  readonly patternType: string;
  readonly invalidation: number | null;
  readonly primaryTarget: number | null;
}

/**
 * Extract Elliott Wave overlay data from a normalised AnalysisData object.
 * Returns null if no elliott_wave signal or wave_points are missing.
 */
export function extractEWaveOverlay(data: AnalysisData): EWaveOverlayData | null {
  const ewSignal = data.signals.find((s) => s.methodology === 'elliott_wave');
  if (!ewSignal) return null;

  const kl = ewSignal.keyLevels;
  const rawPoints = kl['wave_points'];
  if (!Array.isArray(rawPoints) || rawPoints.length === 0) return null;

  const wavePoints: EWavePoint[] = rawPoints
    .filter((p): p is Record<string, unknown> => typeof p === 'object' && p !== null)
    .map((p) => ({
      time: typeof p['time'] === 'string' ? p['time'] : '',
      price: typeof p['price'] === 'number' ? p['price'] : 0,
      label: typeof p['label'] === 'string' ? p['label'] : '',
    }))
    .filter((p) => p.time !== '' && p.price !== 0);

  const rawFibs = kl['fib_levels_detailed'];
  const fibLevels: EFibLevel[] = Array.isArray(rawFibs)
    ? rawFibs
      .filter((f): f is Record<string, unknown> => typeof f === 'object' && f !== null)
      .map((f) => ({
        ratio: typeof f['ratio'] === 'number' ? f['ratio'] : 0,
        price: typeof f['price'] === 'number' ? f['price'] : 0,
        label: typeof f['label'] === 'string' ? f['label'] : '',
        aligned: f['aligned'] === true,
        type: f['type'] === 'extension' ? 'extension' : 'retracement',
      }))
    : [];

  return {
    wavePoints,
    fibLevels,
    patternType: typeof kl['pattern_type'] === 'string' ? kl['pattern_type'] : '',
    invalidation: typeof kl['invalidation'] === 'number' ? kl['invalidation'] : null,
    primaryTarget: typeof kl['primary_target'] === 'number' ? kl['primary_target'] : null,
  };
}

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

/** Client-side cache TTL for analysis data (15 minutes). */
export const ANALYSIS_CACHE_TTL_MS = 900_000;

/** Human-readable names for backend methodology identifiers. */
export const METHODOLOGY_DISPLAY_NAMES: Readonly<Record<string, string>> = {
  wyckoff: 'Wyckoff',
  elliott_wave: 'Elliott Wave',
  ict_smart_money: 'ICT SMC',
  canslim: 'CANSLIM',
  larry_williams: 'Larry Williams',
  sentiment: 'Sentiment',
} as const;

/** Display configuration for a direction label/color pair. */
export interface DirectionConfig {
  readonly label: string;
  readonly colorClass: string;
}

/** Direction-to-display configuration map for badges and labels. */
export const DIRECTION_CONFIG: Readonly<Record<string, DirectionConfig>> = {
  strong_bullish: { label: 'Strong Bull', colorClass: 'text-accent-green' },
  bullish: { label: 'Bullish', colorClass: 'text-accent-green' },
  neutral: { label: 'Neutral', colorClass: 'text-text-muted' },
  bearish: { label: 'Bearish', colorClass: 'text-accent-red' },
  strong_bearish: { label: 'Strong Bear', colorClass: 'text-accent-red' },
} as const;

/** Short labels for signal timeframe badges. */
export const TIMEFRAME_LABELS: Readonly<Record<SignalTimeframe, string>> = {
  short: 'Short',
  medium: 'Med',
  long: 'Long',
} as const;

// ---------------------------------------------------------------------------
// Validation sets (private)
// ---------------------------------------------------------------------------

const VALID_OVERALL_DIRECTIONS: ReadonlySet<string> = new Set<OverallDirection>(
  ['strong_bullish', 'bullish', 'neutral', 'bearish', 'strong_bearish'],
);

const VALID_SIGNAL_DIRECTIONS: ReadonlySet<string> = new Set<SignalDirection>([
  'bullish',
  'bearish',
  'neutral',
]);

const VALID_TIMEFRAMES: ReadonlySet<string> = new Set<SignalTimeframe>([
  'short',
  'medium',
  'long',
]);

// ---------------------------------------------------------------------------
// Helpers -- sanitizers (private)
// ---------------------------------------------------------------------------

/**
 * Defensively coerce an unknown value to `number | null`.
 *
 * Returns the value as a number when it is a finite, non-boolean number;
 * returns `null` for everything else (including `NaN`, `Infinity`, booleans,
 * strings, objects, `undefined`, and `null`).
 *
 * IMPORTANT: The boolean check MUST come first because
 * `typeof true === 'boolean'` but `true` would also pass a naive
 * `typeof value === 'number'` check in JavaScript (bool is a subclass of
 * number in some contexts).
 */
function sanitizeNumber(value: unknown): number | null {
  if (typeof value === 'boolean') return null;
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  return null;
}

// ---------------------------------------------------------------------------
// Normalizers -- enum validators (exported)
// ---------------------------------------------------------------------------

/**
 * Normalise a raw direction value to a valid SignalDirection.
 *
 * Returns the value as-is when it matches a known direction; falls back to
 * `'neutral'` for unknown, missing, or non-string values.
 */
export function normalizeDirection(raw: unknown): SignalDirection {
  if (typeof raw === 'string' && VALID_SIGNAL_DIRECTIONS.has(raw)) {
    return raw as SignalDirection;
  }
  return 'neutral';
}

/**
 * Normalise a raw overall direction value to a valid OverallDirection.
 *
 * Returns the value as-is when it matches a known direction; falls back to
 * `'neutral'` for unknown, missing, or non-string values.
 */
export function normalizeOverallDirection(raw: unknown): OverallDirection {
  if (typeof raw === 'string' && VALID_OVERALL_DIRECTIONS.has(raw)) {
    return raw as OverallDirection;
  }
  return 'neutral';
}

/**
 * Normalise a raw timeframe value to a valid SignalTimeframe.
 *
 * Returns the value as-is when it matches a known timeframe; falls back to
 * `'medium'` for unknown, missing, or non-string values.
 */
export function normalizeTimeframe(raw: unknown): SignalTimeframe {
  if (typeof raw === 'string' && VALID_TIMEFRAMES.has(raw)) {
    return raw as SignalTimeframe;
  }
  return 'medium';
}

// ---------------------------------------------------------------------------
// Normalizers -- composite types (exported)
// ---------------------------------------------------------------------------

/**
 * Normalise a single raw methodology signal from snake_case to camelCase.
 *
 * - Direction and timeframe are validated against known enums.
 * - Confidence is clamped to [0, 1].
 * - key_levels is guarded against non-object/array values.
 */
export function normalizeSignal(raw: AnalysisSignalRaw): AnalysisSignal {
  const rawConfidence = sanitizeNumber(raw.confidence);
  const confidence =
    rawConfidence !== null ? Math.max(0, Math.min(1, rawConfidence)) : 0;

  // Guard key_levels: must be a non-null, non-array object
  const keyLevels: Record<string, unknown> =
    typeof raw.key_levels === 'object' &&
      raw.key_levels !== null &&
      !Array.isArray(raw.key_levels)
      ? raw.key_levels
      : {};

  return {
    ticker: raw.ticker ?? '',
    methodology: raw.methodology ?? '',
    direction: normalizeDirection(raw.direction),
    confidence,
    timeframe: normalizeTimeframe(raw.timeframe),
    reasoning: raw.reasoning ?? '',
    keyLevels,
    timestamp: raw.timestamp ?? '',
  };
}

/**
 * Normalise a single raw timeframe breakdown entry.
 *
 * - Direction is validated against known signal directions.
 * - Confidence is clamped to [0, 1].
 * - Methodologies list is guarded against non-array values.
 */
export function normalizeTimeframeBreakdown(
  raw: TimeframeBreakdownRaw,
): TimeframeBreakdown {
  const rawConfidence = sanitizeNumber(raw.confidence);
  const confidence =
    rawConfidence !== null ? Math.max(0, Math.min(1, rawConfidence)) : 0;

  return {
    direction: normalizeDirection(raw.direction),
    confidence,
    methodologies: Array.isArray(raw.methodologies)
      ? raw.methodologies
      : [],
  };
}

/** Default timeframe breakdown for missing or invalid entries. */
const DEFAULT_TIMEFRAME_BREAKDOWN: TimeframeBreakdown = {
  direction: 'neutral',
  confidence: 0,
  methodologies: [],
};

/**
 * Normalise the full backend analysis response into the display-ready format.
 *
 * - Maps all snake_case fields to camelCase.
 * - Validates enum fields (direction, timeframe) against known values.
 * - Sanitizes all numeric fields through `sanitizeNumber`.
 * - Guards arrays against non-array values.
 * - Guards objects against non-object/array values.
 * - Extracts only `short`, `medium`, `long` keys from timeframe_breakdown.
 * - Provides safe defaults for every field.
 */
export function normalizeAnalysis(raw: AnalysisApiResponse): AnalysisData {
  // -- Composite ----------------------------------------------------------

  const composite = raw.composite;

  const overallConfidenceRaw = sanitizeNumber(composite?.overall_confidence);
  const overallConfidence =
    overallConfidenceRaw !== null
      ? Math.max(0, Math.min(1, overallConfidenceRaw))
      : 0;

  const confluenceCountRaw = sanitizeNumber(composite?.confluence_count);
  const confluenceCount =
    confluenceCountRaw !== null
      ? Math.max(0, Math.round(confluenceCountRaw))
      : 0;

  // Extract timeframe breakdown: only pick short/medium/long with defaults
  const rawBreakdown =
    typeof composite?.timeframe_breakdown === 'object' &&
      composite.timeframe_breakdown !== null &&
      !Array.isArray(composite.timeframe_breakdown)
      ? composite.timeframe_breakdown
      : {};

  const timeframeBreakdown: Record<SignalTimeframe, TimeframeBreakdown> = {
    short: rawBreakdown.short
      ? normalizeTimeframeBreakdown(rawBreakdown.short)
      : { ...DEFAULT_TIMEFRAME_BREAKDOWN },
    medium: rawBreakdown.medium
      ? normalizeTimeframeBreakdown(rawBreakdown.medium)
      : { ...DEFAULT_TIMEFRAME_BREAKDOWN },
    long: rawBreakdown.long
      ? normalizeTimeframeBreakdown(rawBreakdown.long)
      : { ...DEFAULT_TIMEFRAME_BREAKDOWN },
  };

  // Guard weights_used
  const weightsUsed: Record<string, number> =
    typeof composite?.weights_used === 'object' &&
      composite.weights_used !== null &&
      !Array.isArray(composite.weights_used)
      ? composite.weights_used
      : {};

  const normalizedComposite: AnalysisComposite = {
    overallDirection: normalizeOverallDirection(composite?.overall_direction),
    overallConfidence,
    confluenceCount,
    timeframeBreakdown,
    tradeThesis: composite?.trade_thesis ?? '',
    weightsUsed,
    timestamp: composite?.timestamp ?? '',
  };

  // -- Signals ------------------------------------------------------------

  const signals: AnalysisSignal[] = Array.isArray(raw.signals)
    ? raw.signals.map(normalizeSignal)
    : [];

  // -- Metadata -----------------------------------------------------------

  const meta = raw.metadata;

  const durationRaw = sanitizeNumber(meta?.analysis_duration_ms);
  const analysisDurationMs =
    durationRaw !== null ? Math.max(0, Math.round(durationRaw)) : 0;

  const requestedRaw = sanitizeNumber(meta?.methodologies_requested);
  const methodologiesRequested =
    requestedRaw !== null ? Math.max(0, Math.round(requestedRaw)) : 0;

  const completedRaw = sanitizeNumber(meta?.methodologies_completed);
  const methodologiesCompleted =
    completedRaw !== null ? Math.max(0, Math.round(completedRaw)) : 0;

  const failedRaw = sanitizeNumber(meta?.methodologies_failed);
  const methodologiesFailed =
    failedRaw !== null ? Math.max(0, Math.round(failedRaw)) : 0;

  const metadata: AnalysisMetadata = {
    analysisDurationMs,
    methodologiesRequested,
    methodologiesCompleted,
    methodologiesFailed,
    failedMethodologies: Array.isArray(meta?.failed_methodologies)
      ? meta.failed_methodologies
      : [],
    cached: meta?.cached === true,
    dataSourcesUsed: Array.isArray(meta?.data_sources_used)
      ? meta.data_sources_used
      : [],
  };

  // -- Envelope -----------------------------------------------------------

  return {
    symbol: raw.symbol ?? '',
    composite: normalizedComposite,
    signals,
    metadata,
  };
}
