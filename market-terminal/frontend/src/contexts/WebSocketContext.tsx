/**
 * WebSocket context provider with auto-reconnect and channel subscriptions.
 * Follows the TickerContext 4-step pattern: Interface, Context, Provider, Hook.
 * @generated by code-generator (Agent #19)
 */

import {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import type { ReactNode } from 'react';
import type {
  WsConnectionStatus,
  WsServerMessage,
  WsServerMessageType,
  WsClientAction,
  WsMessageMap,
} from '../types/websocket';
import { WS_DEFAULTS, isServerMessage, isConnected } from '../types/websocket';

// ---------------------------------------------------------------------------
// Step 1 -- Interface
// ---------------------------------------------------------------------------

/** Callback signature for message listeners. */
export type WsMessageCallback<T extends WsServerMessageType> = (
  msg: WsMessageMap[T],
) => void;

/** Public surface of the WebSocket context. */
export interface WebSocketContextType {
  /** Current lifecycle status of the connection. */
  readonly status: WsConnectionStatus;
  /** Server-assigned client identifier (available after first `connected` message). */
  readonly clientId: string | null;
  /** Subscribe to a channel. Safe to call before the socket is open. */
  subscribe: (channel: string) => void;
  /** Unsubscribe from a channel. */
  unsubscribe: (channel: string) => void;
  /**
   * Register a typed listener for a specific message type.
   * Returns a cleanup function that removes the listener.
   */
  onMessage: <T extends WsServerMessageType>(
    type: T,
    callback: WsMessageCallback<T>,
  ) => () => void;
}

// ---------------------------------------------------------------------------
// Step 2 -- Context
// ---------------------------------------------------------------------------

const WebSocketContext = createContext<WebSocketContextType | null>(null);

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Build the WebSocket URL from the current page location. */
function buildWsUrl(): string {
  const proto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  return `${proto}//${window.location.host}/api/ws`;
}

/** Send a client action over the socket if it is open. */
function sendAction(ws: WebSocket | null, action: WsClientAction): void {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify(action));
  }
}

// ---------------------------------------------------------------------------
// Step 3 -- Provider
// ---------------------------------------------------------------------------

export function WebSocketProvider({ children }: { children: ReactNode }) {
  // -- public state --
  const [status, setStatus] = useState<WsConnectionStatus>('disconnected');
  const [clientId, setClientId] = useState<string | null>(null);

  // -- refs (stable across renders) --
  const wsRef = useRef<WebSocket | null>(null);
  const hasConnectedRef = useRef(false);

  /** Map from message type to the Set of registered callbacks. */
  const listenersRef = useRef<
    Map<WsServerMessageType, Set<WsMessageCallback<WsServerMessageType>>>
  >(new Map());

  /** Channels the consumer has logically subscribed to, with reference counts.
   *  Multiple components may subscribe to the same channel; the wire-level
   *  subscribe is sent only on 0->1 transition, and unsubscribe only on 1->0. */
  const subscribedChannelsRef = useRef<Map<string, number>>(new Map());

  const reconnectAttemptRef = useRef(0);
  const reconnectTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const pingTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const intentionalCloseRef = useRef(false);

  /** Server-supplied reconnection hints (overrides defaults). */
  const reconnectHintRef = useRef<{
    initial_delay_ms: number;
    max_delay_ms: number;
    multiplier: number;
  } | null>(null);

  // -- internal helpers --------------------------------------------------

  /** Replay all logical subscriptions over the (re-)opened socket. */
  const replaySubscriptions = useCallback((ws: WebSocket) => {
    subscribedChannelsRef.current.forEach((_count, channel) => {
      sendAction(ws, { action: 'subscribe', channel });
    });
  }, []);

  /** Start the keep-alive ping interval. */
  const startPing = useCallback((ws: WebSocket) => {
    if (pingTimerRef.current !== null) {
      clearInterval(pingTimerRef.current);
    }
    pingTimerRef.current = setInterval(() => {
      sendAction(ws, { action: 'ping' });
    }, WS_DEFAULTS.pingIntervalMs);
  }, []);

  /** Stop the keep-alive ping interval. */
  const stopPing = useCallback(() => {
    if (pingTimerRef.current !== null) {
      clearInterval(pingTimerRef.current);
      pingTimerRef.current = null;
    }
  }, []);

  /** Dispatch a parsed server message to all matching listeners. */
  const dispatch = useCallback((msg: WsServerMessage) => {
    const cbs = listenersRef.current.get(msg.type);
    if (cbs) {
      cbs.forEach((cb) => {
        try {
          (cb as WsMessageCallback<typeof msg.type>)(msg as never);
        } catch (err) {
          // Listener errors must not crash the provider.
          console.error('[WS] listener error for message type "%s":', msg.type, err);
        }
      });
    }
  }, []);

  /** Schedule a reconnection attempt with exponential back-off + jitter. */
  const scheduleReconnect = useCallback(() => {
    if (reconnectAttemptRef.current >= WS_DEFAULTS.maxReconnectAttempts) {
      setStatus('disconnected');
      return;
    }

    setStatus('reconnecting');

    const hint = reconnectHintRef.current;
    const base = hint?.initial_delay_ms ?? WS_DEFAULTS.reconnectDelayMs;
    const mult = hint?.multiplier ?? WS_DEFAULTS.reconnectMultiplier;
    const cap = hint?.max_delay_ms ?? WS_DEFAULTS.maxReconnectDelayMs;

    const delay = Math.min(
      base * Math.pow(mult, reconnectAttemptRef.current),
      cap,
    );
    // Add random jitter of +/-25 % to avoid thundering herd.
    const jitter = delay * (0.75 + Math.random() * 0.5);

    reconnectAttemptRef.current += 1;

    reconnectTimerRef.current = setTimeout(() => {
      connect(); // eslint-disable-line @typescript-eslint/no-use-before-define
    }, jitter);
  }, []); // eslint-disable-line react-hooks/exhaustive-deps -- connect is stable via ref

  // -- connect ------------------------------------------------------------

  const connect = useCallback(() => {
    // Tear down any previous socket.
    if (wsRef.current) {
      wsRef.current.onopen = null;
      wsRef.current.onmessage = null;
      wsRef.current.onerror = null;
      wsRef.current.onclose = null;
      if (
        wsRef.current.readyState === WebSocket.OPEN ||
        wsRef.current.readyState === WebSocket.CONNECTING
      ) {
        wsRef.current.close();
      }
      wsRef.current = null;
    }

    setStatus('connecting');

    const ws = new WebSocket(buildWsUrl());
    wsRef.current = ws;

    ws.onopen = () => {
      setStatus('connected');
      reconnectAttemptRef.current = 0;
    };

    ws.onmessage = (event: MessageEvent) => {
      let parsed: unknown;
      try {
        parsed = JSON.parse(event.data as string);
      } catch {
        console.warn('[WS] failed to parse incoming message');
        return;
      }

      if (!isServerMessage(parsed)) return;

      const msg = parsed as WsServerMessage;

      // Handle `connected` lifecycle message.
      if (isConnected(msg)) {
        setClientId(msg.client_id);
        if (msg.reconnect_hint) {
          reconnectHintRef.current = {
            initial_delay_ms: msg.reconnect_hint.initial_delay_ms,
            max_delay_ms: msg.reconnect_hint.max_delay_ms,
            multiplier: msg.reconnect_hint.multiplier,
          };
        }
        replaySubscriptions(ws);
        startPing(ws);
      }

      // Dispatch to listeners (including `connected` itself).
      dispatch(msg);
    };

    ws.onerror = () => {
      console.warn('[WS] connection error (reconnection will follow)');
    };

    ws.onclose = () => {
      stopPing();
      if (intentionalCloseRef.current) {
        setStatus('disconnected');
      } else {
        scheduleReconnect();
      }
    };
  }, [dispatch, replaySubscriptions, scheduleReconnect, startPing, stopPing]);

  // -- public callbacks ---------------------------------------------------

  const subscribe = useCallback((channel: string) => {
    const prev = subscribedChannelsRef.current.get(channel) ?? 0;
    subscribedChannelsRef.current.set(channel, prev + 1);
    // Only send wire-level subscribe on the 0 -> 1 transition.
    if (prev === 0) {
      sendAction(wsRef.current, { action: 'subscribe', channel });
    }
  }, []);

  const unsubscribe = useCallback((channel: string) => {
    const prev = subscribedChannelsRef.current.get(channel) ?? 0;
    if (prev <= 1) {
      subscribedChannelsRef.current.delete(channel);
      // Only send wire-level unsubscribe when no consumers remain.
      sendAction(wsRef.current, { action: 'unsubscribe', channel });
    } else {
      subscribedChannelsRef.current.set(channel, prev - 1);
    }
  }, []);

  const onMessage = useCallback(
    <T extends WsServerMessageType>(
      type: T,
      callback: WsMessageCallback<T>,
    ): (() => void) => {
      let set = listenersRef.current.get(type);
      if (!set) {
        set = new Set();
        listenersRef.current.set(type, set);
      }
      const cb = callback as WsMessageCallback<WsServerMessageType>;
      set.add(cb);

      return () => {
        const s = listenersRef.current.get(type);
        if (s) {
          s.delete(cb);
          if (s.size === 0) {
            listenersRef.current.delete(type);
          }
        }
      };
    },
    [],
  );

  // -- lifecycle effects --------------------------------------------------

  // Mount: open connection (guarded for StrictMode double-invoke).
  useEffect(() => {
    if (hasConnectedRef.current) return;
    hasConnectedRef.current = true;
    connect();
  }, [connect]);

  // Unmount: tear down cleanly.
  useEffect(() => {
    return () => {
      intentionalCloseRef.current = true;

      if (reconnectTimerRef.current !== null) {
        clearTimeout(reconnectTimerRef.current);
        reconnectTimerRef.current = null;
      }
      stopPing();

      if (wsRef.current) {
        wsRef.current.onopen = null;
        wsRef.current.onmessage = null;
        wsRef.current.onerror = null;
        wsRef.current.onclose = null;
        if (
          wsRef.current.readyState === WebSocket.OPEN ||
          wsRef.current.readyState === WebSocket.CONNECTING
        ) {
          wsRef.current.close();
        }
        wsRef.current = null;
      }
    };
  }, [stopPing]);

  // -- context value (stable reference) -----------------------------------

  const value = useMemo<WebSocketContextType>(
    () => ({ status, clientId, subscribe, unsubscribe, onMessage }),
    [status, clientId, subscribe, unsubscribe, onMessage],
  );

  return (
    <WebSocketContext.Provider value={value}>
      {children}
    </WebSocketContext.Provider>
  );
}

// ---------------------------------------------------------------------------
// Step 4 -- Hook
// ---------------------------------------------------------------------------

/**
 * Consume the WebSocket context.
 * Must be called within a {@link WebSocketProvider}.
 */
export function useWebSocketContext(): WebSocketContextType {
  const ctx = useContext(WebSocketContext);
  if (ctx === null) {
    throw new Error(
      'useWebSocketContext must be used within a WebSocketProvider',
    );
  }
  return ctx;
}
